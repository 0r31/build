From b34653e779f9ece72e074106ef6d256f55480734 Mon Sep 17 00:00:00 2001
From: Ondrej Jirman <megous@megous.com>
Date: Mon, 13 Jul 2020 00:16:47 +0200
Subject: [PATCH 335/346] misc: modem-power: Add serdev support

The driver can alternatively register as a serdev, and monitor/control
the main UART of the modem.

Signed-off-by: Ondrej Jirman <megous@megous.com>
---
 drivers/misc/modem-power.c | 169 +++++++++++++++++++++++++++----------
 1 file changed, 126 insertions(+), 43 deletions(-)

diff --git a/drivers/misc/modem-power.c b/drivers/misc/modem-power.c
index 4bc2fd43979e..e9abb42005c7 100644
--- a/drivers/misc/modem-power.c
+++ b/drivers/misc/modem-power.c
@@ -93,6 +93,12 @@ struct mpwr_dev {
 	struct device *dev;
 	const struct mpwr_variant* variant;
 
+	/* serdev */
+	struct serdev_device *serdev;
+	wait_queue_head_t rdy_wq;
+	char rcvbuf[4096];
+	size_t rcvbuf_fill;
+
 	/* power */
 	struct regulator *regulator;
 
@@ -103,6 +109,7 @@ struct mpwr_dev {
 	struct gpio_desc *sleep_gpio;
 	struct gpio_desc *rts_gpio;
 	struct gpio_desc *dtr_gpio;
+	struct gpio_desc *host_ready_gpio;
 
 	/* inputs */
 	struct gpio_desc *cts_gpio;
@@ -403,6 +410,7 @@ static const struct mpwr_gpio mpwr_eg25_gpios[] = {
 	MPWR_GPIO_DEF(sleep, GPIOD_OUT_LOW, false),
 	MPWR_GPIO_DEF(dtr, GPIOD_OUT_LOW, false),
 	MPWR_GPIO_DEF(rts, GPIOD_OUT_LOW, false),
+	MPWR_GPIO_DEF(host_ready, GPIOD_OUT_HIGH, false),
 
 	MPWR_GPIO_DEF(cts, GPIOD_IN, false),
 	MPWR_GPIO_DEF_IRQ(status, GPIOD_IN, false,
@@ -865,10 +873,9 @@ static const struct attribute_group mpwr_group = {
 	.attrs = mpwr_attrs,
 };
 
-static int mpwr_probe(struct platform_device *pdev)
+static int mpwr_probe_generic(struct device *dev, struct mpwr_dev **mpwr_out)
 {
 	struct mpwr_dev *mpwr;
-	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
 	struct device *sdev;
 	const char* cdev_name = NULL;
@@ -880,14 +887,14 @@ static int mpwr_probe(struct platform_device *pdev)
 
 	mpwr->cts_last = -1;
 
-	mpwr->variant = of_device_get_match_data(&pdev->dev);
+	mpwr->variant = of_device_get_match_data(dev);
 	if (!mpwr->variant)
 		return -EINVAL;
 	mpwr->powerdown_delay = mpwr->variant->powerdown_delay;
 
 	mpwr->dev = dev;
-	platform_set_drvdata(pdev, mpwr);
 	init_waitqueue_head(&mpwr->waitqueue);
+	init_waitqueue_head(&mpwr->rdy_wq);
 	spin_lock_init(&mpwr->lock);
 	INIT_WORK(&mpwr->work, &mpwr_work_handler);
         INIT_DELAYED_WORK(&mpwr->dwork, mpwr_dwork);
@@ -1004,6 +1011,7 @@ static int mpwr_probe(struct platform_device *pdev)
 	mod_timer(&mpwr->wd_timer, jiffies + msecs_to_jiffies(1000));
 
 	dev_info(dev, "modem power manager ready");
+	*mpwr_out = mpwr;
 
 	return 0;
 
@@ -1018,10 +1026,8 @@ static int mpwr_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int mpwr_remove(struct platform_device *pdev)
+static int mpwr_remove_generic(struct mpwr_dev *mpwr)
 {
-	struct mpwr_dev *mpwr = platform_get_drvdata(pdev);
-
 	del_timer_sync(&mpwr->wd_timer);
         cancel_delayed_work_sync(&mpwr->dwork);
 
@@ -1033,12 +1039,29 @@ static int mpwr_remove(struct platform_device *pdev)
 	cdev_del(&mpwr->cdev);
 	unregister_chrdev(mpwr->major, "modem-power");
 
-	if (mpwr->wakeup_irq > 0)
-		devm_free_irq(mpwr->dev, mpwr->wakeup_irq, mpwr);
-
 	return 0;
 }
 
+static int mpwr_probe(struct platform_device *pdev)
+{
+        struct mpwr_dev* mpwr;
+        int ret;
+
+	ret = mpwr_probe_generic(&pdev->dev, &mpwr);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, mpwr);
+        return 0;
+}
+
+static int mpwr_remove(struct platform_device *pdev)
+{
+	struct mpwr_dev *mpwr = platform_get_drvdata(pdev);
+
+	return mpwr_remove_generic(mpwr);
+}
+
 static void mpwr_shutdown(struct platform_device *pdev)
 {
 	struct mpwr_dev *mpwr = platform_get_drvdata(pdev);
@@ -1048,15 +1071,59 @@ static void mpwr_shutdown(struct platform_device *pdev)
 }
 
 #if 0
+	/* write is only buffered synchronously */
+	ret = serdev_device_write(serdev, buf, count, MAX_SCHEDULE_TIMEOUT);
+	if (ret < 0 || ret < count)
+		return ret;
+
+	/* FIXME: determine if interrupted? */
+	serdev_device_wait_until_sent(serdev, 0);
+#endif
+
+static void mpwr_serdev_receive_msg(struct mpwr_dev *mpwr, const char *msg)
+{
+	dev_info(mpwr->dev, "recv: %s\n", msg);
+
+	if (!strcmp(msg, "RDY"))
+		wake_up_interruptible(&mpwr->rdy_wq);
+}
+
 static int mpwr_serdev_receive_buf(struct serdev_device *serdev,
 				   const unsigned char *buf, size_t count)
 {
 	struct mpwr_dev *mpwr = serdev_device_get_drvdata(serdev);
-        int ret = 0;
+	size_t avail = sizeof(mpwr->rcvbuf) - mpwr->rcvbuf_fill;
+	char* p;
 
-	//wake_up_interruptible(&data->power_wait);
+	if (avail < count)
+		count = avail;
 
-        return ret;
+	if (avail > 0) {
+		memcpy(mpwr->rcvbuf + mpwr->rcvbuf_fill, buf, count);
+		mpwr->rcvbuf_fill += count;
+	}
+
+	while (true) {
+		p = strnstr(mpwr->rcvbuf, "\r\n", mpwr->rcvbuf_fill);
+		if (p) {
+			if (p > mpwr->rcvbuf) {
+				*p = 0;
+				mpwr_serdev_receive_msg(mpwr, mpwr->rcvbuf);
+			}
+
+			mpwr->rcvbuf_fill -= (p - mpwr->rcvbuf) + 2;
+			memmove(mpwr->rcvbuf, p + 2, mpwr->rcvbuf_fill);
+		} else {
+			if (sizeof(mpwr->rcvbuf) - mpwr->rcvbuf_fill == 0) {
+				mpwr->rcvbuf_fill = 0;
+				dev_warn(mpwr->dev, "rcvbuf overflow\n");
+			}
+
+			break;
+		}
+	}
+
+        return count;
 }
 
 static const struct serdev_device_ops mpwr_serdev_ops = {
@@ -1067,61 +1134,66 @@ static const struct serdev_device_ops mpwr_serdev_ops = {
 static int mpwr_serdev_probe(struct serdev_device *serdev)
 {
 	struct device *dev = &serdev->dev;
-         struct device_node *node = serdev->dev.of_node;
-         u32 speed = 9600;
-
-         serdev_device_set_drvdata(serdev, data);
-         serdev_device_set_client_ops(serdev, &mpwr_serdev_ops);
-
-         of_property_read_u32(node, "current-speed", &speed);
+	//struct device_node *node = serdev->dev.of_node;
+        struct mpwr_dev* mpwr;
+	u32 speed = 115200;
+        int ret;
 
-	 ret = serdev_device_open(data->serdev);
-	 if (ret) {
-		 goto out_unlock;
-	 }
+	ret = mpwr_probe_generic(dev, &mpwr);
+	if (ret)
+		return ret;
 
-	 serdev_device_set_baudrate(data->serdev, data->speed);
-	 serdev_device_set_flow_control(data->serdev, false);
+	serdev_device_set_drvdata(serdev, mpwr);
+	serdev_device_set_client_ops(serdev, &mpwr_serdev_ops);
+	mpwr->serdev = serdev;
 
-	 /* write is only buffered synchronously */
-	 ret = serdev_device_write(serdev, buf, count, MAX_SCHEDULE_TIMEOUT);
-	 if (ret < 0 || ret < count)
-		 return ret;
+	ret = serdev_device_open(mpwr->serdev);
+	if (ret) {
+		dev_err(dev, "error opening serdev (%d)\n", ret);
+		mpwr_remove_generic(mpwr);
+		return ret;
+	}
 
-	 /* FIXME: determine if interrupted? */
-	 serdev_device_wait_until_sent(serdev, 0);
+	//of_property_read_u32(node, "current-speed", &speed);
+	//XXX: we probably won't need setting speed from DTS
 
+	serdev_device_set_baudrate(serdev, speed);
+	serdev_device_set_flow_control(serdev, false);
 
-	 serdev_device_close(data->serdev);
+        return 0;
 }
 
 static void mpwr_serdev_remove(struct serdev_device *serdev)
 {
 	struct mpwr_dev *mpwr = serdev_device_get_drvdata(serdev);
 
+	serdev_device_close(serdev);
+
+	mpwr_remove_generic(mpwr);
 }
 
-static const struct of_device_id mpwr_of_match[];
+static const struct of_device_id mpwr_of_match_serdev[] = {
+	{ .compatible = "quectel,eg25",
+	  .data = &mpwr_eg25_variant },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mpwr_of_match_serdev);
 
 static struct serdev_device_driver mpwr_serdev_driver = {
         .probe  = mpwr_serdev_probe,
         .remove = mpwr_serdev_remove,
         .driver = {
                 .name = DRIVER_NAME,
-                .of_match_table = mpwr_of_match,
+                .of_match_table = mpwr_of_match_serdev,
         },
 };
-module_serdev_device_driver(mpwr_serdev_driver);
-#endif
 
-static const struct of_device_id mpwr_of_match[] = {
+static const struct of_device_id mpwr_of_match_plat[] = {
 	{ .compatible = "zte,mg3732",
 	  .data = &mpwr_mg2723_variant },
-	{ .compatible = "quectel,eg25",
-	  .data = &mpwr_eg25_variant },
 	{},
 };
-MODULE_DEVICE_TABLE(of, mpwr_of_match);
+MODULE_DEVICE_TABLE(of, mpwr_of_match_plat);
 
 static struct platform_driver mpwr_platform_driver = {
 	.probe = mpwr_probe,
@@ -1129,7 +1201,7 @@ static struct platform_driver mpwr_platform_driver = {
 	.shutdown = mpwr_shutdown,
 	.driver = {
 		.name = DRIVER_NAME,
-		.of_match_table = mpwr_of_match,
+		.of_match_table = mpwr_of_match_plat,
 	},
 };
 
@@ -1141,15 +1213,26 @@ static int __init mpwr_driver_init(void)
 	if (IS_ERR(mpwr_class))
 		return PTR_ERR(mpwr_class);
 
+	ret = serdev_device_driver_register(&mpwr_serdev_driver);
+	if (ret)
+		goto err_class;
+
 	ret = platform_driver_register(&mpwr_platform_driver);
 	if (ret)
-		class_destroy(mpwr_class);
+		goto err_serdev;
 
 	return ret;
+
+err_serdev:
+	serdev_device_driver_unregister(&mpwr_serdev_driver);
+err_class:
+	class_destroy(mpwr_class);
+	return ret;
 }
 
 static void __exit mpwr_driver_exit(void)
 {
+	serdev_device_driver_unregister(&mpwr_serdev_driver);
 	platform_driver_unregister(&mpwr_platform_driver);
 	class_destroy(mpwr_class);
 }
-- 
2.25.1

